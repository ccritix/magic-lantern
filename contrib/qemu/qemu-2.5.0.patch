diff --git a/cpu-exec.c b/cpu-exec.c
index c88d0ff..3d1323e 100644
--- a/cpu-exec.c
+++ b/cpu-exec.c
@@ -500,8 +500,17 @@ int cpu_exec(CPUState *cpu)
                     tcg_ctx.tb_ctx.tb_invalidated_flag = 0;
                 }
                 if (qemu_loglevel_mask(CPU_LOG_EXEC)) {
+#if defined(TARGET_ARM)
+                    /* rather than logging just PC, also log the disassembled code */
+                    if (!singlestep) {
+                        /* separate translation blocks by newlines */
+                        qemu_log("\n");
+                    }
+                    log_target_disas(cpu, tb->pc, tb->size, 0);
+#else
                     qemu_log("Trace %p [" TARGET_FMT_lx "] %s\n",
                              tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));
+#endif
                 }
                 /* see if we can patch the calling TB. When the TB
                    spans two pages, we cannot safely do a direct
diff --git a/hw/arm/Makefile.objs b/hw/arm/Makefile.objs
index 2195b60..e3e2c14 100644
--- a/hw/arm/Makefile.objs
+++ b/hw/arm/Makefile.objs
@@ -6,6 +6,7 @@ obj-y += tosa.o versatilepb.o vexpress.o virt.o xilinx_zynq.o z2.o
 obj-$(CONFIG_ACPI) += virt-acpi-build.o
 obj-y += netduino2.o
 obj-y += sysbus-fdt.o
+include ../hw/eos/Makefile.objs
 
 obj-y += armv7m.o exynos4210.o pxa2xx.o pxa2xx_gpio.o pxa2xx_pic.o
 obj-$(CONFIG_DIGIC) += digic.o
diff --git a/memory.c b/memory.c
index e193658..9de7251 100644
--- a/memory.c
+++ b/memory.c
@@ -1761,7 +1761,7 @@ static void memory_region_update_container_subregions(MemoryRegion *subregion)
                          int128_make64(other->addr))) {
             continue;
         }
-#if 0
+#if 1
         printf("warning: subregion collision %llx/%llx (%s) "
                "vs %llx/%llx (%s)\n",
                (unsigned long long)offset,
@@ -1798,6 +1798,9 @@ void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
+    fprintf(stderr, "%08X - %08X: %s\n",
+                     (int)offset, (int)offset + (int)subregion->size.lo - 1,
+                     subregion->name);
     subregion->may_overlap = false;
     subregion->priority = 0;
     memory_region_add_subregion_common(mr, offset, subregion);
diff --git a/target-arm/cpu.c b/target-arm/cpu.c
index 30739fc..3a08417 100644
--- a/target-arm/cpu.c
+++ b/target-arm/cpu.c
@@ -711,6 +711,31 @@ static void arm926_initfn(Object *obj)
     cpu->reset_sctlr = 0x00090078;
 }
 
+static void arm946eos_initfn(Object *obj)
+{
+    ARMCPU *cpu = ARM_CPU(obj);
+    set_feature(&cpu->env, ARM_FEATURE_V5);
+    set_feature(&cpu->env, ARM_FEATURE_MPU);
+    set_feature(&cpu->env, ARM_FEATURE_XSCALE); /* for MCR p15, 0,R0,c9,c1,0 */
+    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);
+    cpu->midr = 0x41059461;
+    cpu->ctr = (7 << 25) | (1 << 24) | (4 << 18) | (4 << 15) \
+             | (2 << 12) | (4 << 6) | (4 << 3) | (2 << 0);
+    cpu->reset_sctlr = 0x00000078;
+}
+
+static void arm_digic6_eos_initfn(Object *obj)
+{
+    /* this CPU supports Thumb-2 instructions and also SDIV */
+    ARMCPU *cpu = ARM_CPU(obj);
+    set_feature(&cpu->env, ARM_FEATURE_V8);
+    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);
+    cpu->midr = 0x41059461;
+    cpu->ctr = (7 << 25) | (1 << 24) | (4 << 18) | (4 << 15) \
+             | (2 << 12) | (4 << 6) | (4 << 3) | (2 << 0);
+    cpu->reset_sctlr = 0x00000078;
+}
+
 static void arm946_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
@@ -1328,6 +1353,8 @@ typedef struct ARMCPUInfo {
 static const ARMCPUInfo arm_cpus[] = {
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
     { .name = "arm926",      .initfn = arm926_initfn },
+    { .name = "arm946eos",   .initfn = arm946eos_initfn },
+    { .name = "arm-digic6-eos",   .initfn = arm_digic6_eos_initfn },
     { .name = "arm946",      .initfn = arm946_initfn },
     { .name = "arm1026",     .initfn = arm1026_initfn },
     /* What QEMU calls "arm1136-r2" is actually the 1136 r0p2, i.e. an
diff --git a/target-arm/helper.c b/target-arm/helper.c
index afc4163..f526e24 100644
--- a/target-arm/helper.c
+++ b/target-arm/helper.c
@@ -5891,11 +5891,16 @@ void arm_cpu_do_interrupt(CPUState *cs)
     /* Switch to the new mode, and to the correct instruction set.  */
     env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;
     env->daif |= mask;
+
+    /* this code breaks DryOS task scheduler */
+    /* FIXME: only disable it for EOS CPUs */
+
     /* this is a lie, as the was no c1_sys on V4T/V5, but who cares
      * and we should just guard the thumb mode on V4 */
-    if (arm_feature(env, ARM_FEATURE_V4T)) {
-        env->thumb = (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;
-    }
+    //~ if (arm_feature(env, ARM_FEATURE_V4T)) {
+        //~ env->thumb = (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;
+    //~ }
+
     env->regs[14] = env->regs[15] + offset;
     env->regs[15] = addr;
     cs->interrupt_request |= CPU_INTERRUPT_EXITTB;
