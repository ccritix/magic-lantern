diff --git a/cpu-exec.c b/cpu-exec.c
index c88d0ff..42e7863 100644
--- a/cpu-exec.c
+++ b/cpu-exec.c
@@ -31,6 +31,7 @@
 #include "hw/i386/apic.h"
 #endif
 #include "sysemu/replay.h"
+#include "hw/boards.h"
 
 /* -icount align implementation. */
 
@@ -500,8 +501,112 @@ int cpu_exec(CPUState *cpu)
                     tcg_ctx.tb_ctx.tb_invalidated_flag = 0;
                 }
                 if (qemu_loglevel_mask(CPU_LOG_EXEC)) {
+#if defined(TARGET_ARM)
+                    /* rather than logging just PC, also log the disassembled code */
+                    if (!singlestep) {
+                        /* separate translation blocks by newlines */
+                        qemu_log("\n");
+                    }
+                    log_target_disas(cpu, tb->pc, tb->size, 0);
+#else
                     qemu_log("Trace %p [" TARGET_FMT_lx "] %s\n",
                              tb->tc_ptr, tb->pc, lookup_symbol(tb->pc));
+#endif
+                }
+
+                if (qemu_loglevel_mask(EOS_LOG_CALLS))
+                {
+#if defined(TARGET_ARM)
+                    ARMCPU *arm_cpu = ARM_CPU(cpu);
+                    CPUARMState *env = &arm_cpu->env;
+                    
+                    static FILE * idc = NULL;
+                    static uint32_t prev_pc = 0;
+                    static uint32_t prev_lr = 0;
+                    static uint32_t prev_sp = 0;
+                    static uint32_t prev_size = 0;
+                    if (!idc)
+                    {
+                        char idc_path[100];
+
+                        snprintf(idc_path, sizeof(idc_path), "%s.idc", MACHINE_GET_CLASS(current_machine)->name);
+                        fprintf(stderr, "Exporting called functions to %s.\n", idc_path);
+                        idc = fopen(idc_path, "w");
+                        assert(idc);
+                        
+                        /* QEMU is usually closed with CTRL-C, so call this when finished */
+                        void close_idc(void)
+                        {
+                            fprintf(idc, "}\n");
+                            fclose(idc);
+                        }
+                        atexit(close_idc);
+
+                        fprintf(idc, "/* List of functions called during execution. */\n");
+                        fprintf(idc, "/* Generated from QEMU. */\n\n");
+                        fprintf(idc, "#include <idc.idc>\n\n");
+                        fprintf(idc, "static main() {\n");
+                    }
+                    uint32_t pc = env->regs[15];
+                    uint32_t lr = env->regs[14];
+                    uint32_t sp = env->regs[13];
+                    assert(pc == tb->pc);
+
+                    if (0)
+                    {
+                        fprintf(stderr, "   * PC:%x->%x LR:%x->%x SP:%x->%x */\n",
+                            prev_pc, pc, prev_lr, lr, prev_sp, sp
+                        );
+                    }
+                    
+                    /* bit array for every possible PC & ~3 */
+                    static uint32_t saved_pcs[(1 << 30) / 32] = {0};
+                    
+                    /* when a function call is made:
+                     * - LR is updated with the return address
+                     * - stack is decremented
+                     * - note: the above might also happen during a context switch,
+                     *   so use a heuristic to filter them out
+                     */
+                    if (lr != prev_lr && sp <= prev_sp &&
+                        abs((int)sp - (int)prev_sp) < 1024)
+                    {
+                        /* log each called function to IDC, only once */
+                        int pca = pc >> 2;
+                        if (!(saved_pcs[pca/32] & (1 << (pca%32))))
+                        {
+                            saved_pcs[pca/32] |= (1 << pca%32);
+                            
+                            /* log_target_disas writes to stdout; redirect it to our output file */
+                            /* todo: any other threads that might output to stdout? */
+                            fflush(stdout); fflush(idc);
+                            int old = dup(fileno(stdout));
+                            dup2(fileno(idc), fileno(stderr));
+                            fprintf(stderr, "  /* from "); log_target_disas(cpu, prev_pc, prev_size, 0);
+                            fprintf(stderr, "   *   -> "); log_target_disas(cpu, tb->pc, tb->size, 0);
+                            fprintf(stderr, "   * PC:%x->%x LR:%x->%x SP:%x->%x */\n",
+                                prev_pc, pc, prev_lr, lr, prev_sp, sp
+                            );
+                            fprintf(stderr, "  SetReg(0x%X, \"T\", %d);\n", pc, env->thumb);
+                            fprintf(stderr, "  MakeCode(0x%X);\n", pc);
+                            fprintf(stderr, "  MakeFunction(0x%X, BADADDR);\n", pc);
+                            fprintf(stderr, "\n");
+                            dup2(old, fileno(stderr));
+                        }
+
+                        /* log each call to console */
+                        fprintf(stderr, "%08X: call 0x%X (%s)\n", prev_pc, pc, env->thumb ? "Thumb" : "ARM");
+                    }
+                    
+                    if (pc != prev_pc && pc == (prev_lr & ~1))
+                    {
+                        fprintf(stderr, "%08X: return to 0x%X (%s)\n", prev_pc, pc, env->thumb ? "Thumb" : "ARM");
+                    }
+                    prev_pc = pc;
+                    prev_lr = lr;
+                    prev_sp = sp;
+                    prev_size = tb->size;
+#endif
                 }
                 /* see if we can patch the calling TB. When the TB
                    spans two pages, we cannot safely do a direct
diff --git a/hw/arm/Makefile.objs b/hw/arm/Makefile.objs
index 2195b60..e3e2c14 100644
--- a/hw/arm/Makefile.objs
+++ b/hw/arm/Makefile.objs
@@ -6,6 +6,7 @@ obj-y += tosa.o versatilepb.o vexpress.o virt.o xilinx_zynq.o z2.o
 obj-$(CONFIG_ACPI) += virt-acpi-build.o
 obj-y += netduino2.o
 obj-y += sysbus-fdt.o
+include ../hw/eos/Makefile.objs
 
 obj-y += armv7m.o exynos4210.o pxa2xx.o pxa2xx_gpio.o pxa2xx_pic.o
 obj-$(CONFIG_DIGIC) += digic.o
diff --git a/include/qemu/log.h b/include/qemu/log.h
index 362cbc4..809426e 100644
--- a/include/qemu/log.h
+++ b/include/qemu/log.h
@@ -42,6 +42,10 @@ static inline bool qemu_log_enabled(void)
 #define CPU_LOG_MMU        (1 << 12)
 #define CPU_LOG_TB_NOCHAIN (1 << 13)
 
+#define EOS_LOG_IO         (1 << 14)
+#define EOS_LOG_UART       (1 << 15)
+#define EOS_LOG_CALLS      (1 << 16)
+
 /* Returns true if a bit is set in the current loglevel mask
  */
 static inline bool qemu_loglevel_mask(int mask)
diff --git a/memory.c b/memory.c
index e193658..9de7251 100644
--- a/memory.c
+++ b/memory.c
@@ -1761,7 +1761,7 @@ static void memory_region_update_container_subregions(MemoryRegion *subregion)
                          int128_make64(other->addr))) {
             continue;
         }
-#if 0
+#if 1
         printf("warning: subregion collision %llx/%llx (%s) "
                "vs %llx/%llx (%s)\n",
                (unsigned long long)offset,
@@ -1798,6 +1798,9 @@ void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
+    fprintf(stderr, "%08X - %08X: %s\n",
+                     (int)offset, (int)offset + (int)subregion->size.lo - 1,
+                     subregion->name);
     subregion->may_overlap = false;
     subregion->priority = 0;
     memory_region_add_subregion_common(mr, offset, subregion);
diff --git a/qemu-log.c b/qemu-log.c
index 7cb01a8..d45c7c0 100644
--- a/qemu-log.c
+++ b/qemu-log.c
@@ -120,6 +120,13 @@ const QEMULogItem qemu_log_items[] = {
     { CPU_LOG_TB_NOCHAIN, "nochain",
       "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"
       "complete traces" },
+      
+    { EOS_LOG_IO, "io",
+      "EOS: log low-level I/O activity" },
+    { EOS_LOG_UART, "uart",
+      "EOS: log low-level UART activity" },
+    { EOS_LOG_CALLS, "calls",
+      "EOS: log function calls and export them to IDA" },
     { 0, NULL, NULL },
 };
 
diff --git a/target-arm/cpu.c b/target-arm/cpu.c
index 30739fc..79babf9 100644
--- a/target-arm/cpu.c
+++ b/target-arm/cpu.c
@@ -501,8 +501,9 @@ static void arm_cpu_initfn(Object *obj)
 static Property arm_cpu_reset_cbar_property =
             DEFINE_PROP_UINT64("reset-cbar", ARMCPU, reset_cbar, 0);
 
+/* fixme: how to change this property from machine code? */
 static Property arm_cpu_reset_hivecs_property =
-            DEFINE_PROP_BOOL("reset-hivecs", ARMCPU, reset_hivecs, false);
+            DEFINE_PROP_BOOL("reset-hivecs", ARMCPU, reset_hivecs, true);
 
 static Property arm_cpu_rvbar_property =
             DEFINE_PROP_UINT64("rvbar", ARMCPU, rvbar, 0);
@@ -711,6 +712,100 @@ static void arm926_initfn(Object *obj)
     cpu->reset_sctlr = 0x00090078;
 }
 
+/* cache lockdown emulation */
+/* note: the model is very incomplete, just enough to emulate
+ * the cache hacks from Magic Lantern */
+static uint64_t eos_cache_lockdown_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    printf("Lockdown read %x\n", ri->crm);
+    return 0;
+}
+
+static void eos_cache_patch(uint32_t addr, uint32_t value)
+{
+    uint32_t old;
+    cpu_physical_memory_read(addr, &old, sizeof(old));
+    
+    if (value != old)
+    {
+        printf("Cache patch: [%08X] <- %X\n", addr, value);
+        cpu_physical_memory_write(addr, &value, sizeof(value));
+    }
+}
+
+static void eos_cache_lockdown_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t val)
+{
+    static uint32_t index = 0;
+    static uint32_t itag = 0;
+    static uint32_t dtag = 0;
+
+    switch (ri->crm)
+    {
+        case 0:             /* cache debug index register */
+            index = val;
+            break;
+        
+        case 1:             /* icache tag */
+            itag = val;
+            break;
+        
+        case 2:             /* dcache tag */
+            dtag = val;
+            break;
+        
+        case 3:             /* icache value */
+            eos_cache_patch((itag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+        
+        case 4:             /* dcache value */
+            eos_cache_patch((dtag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+    }
+}
+
+/* similar to not_v6_cp_reginfo, but .crn was changed from 7 to 15 */
+/* note: this conflicts with ARM_FEATURE_DUMMY_C15_REGS */
+static const ARMCPRegInfo eos_digic5_cp_reginfo[] = {
+    { .name = "WFI_eos",     .cp = 15, .crn = 15, .crm = 8, .opc1 = 0, .opc2 = 2,
+      .access = PL1_W,  .type = ARM_CP_WFI },
+    { .name = "CacheDbgIdx", .cp = 15, .crn = 15, .crm = 0, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheTag",   .cp = 15, .crn = 15, .crm = 1, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheTag",   .cp = 15, .crn = 15, .crm = 2, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheVal",   .cp = 15, .crn = 15, .crm = 3, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheVal",   .cp = 15, .crn = 15, .crm = 4, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    REGINFO_SENTINEL
+};
+
+static void arm946eos_initfn(Object *obj)
+{
+    ARMCPU *cpu = ARM_CPU(obj);
+    set_feature(&cpu->env, ARM_FEATURE_V5);
+    set_feature(&cpu->env, ARM_FEATURE_MPU);
+    set_feature(&cpu->env, ARM_FEATURE_XSCALE); /* for MCR p15, 0,R0,c9,c1,0 */
+    cpu->midr = 0x41059461;
+    cpu->ctr = (7 << 25) | (1 << 24) | (4 << 18) | (4 << 15) \
+             | (2 << 12) | (4 << 6) | (4 << 3) | (2 << 0);
+    cpu->reset_sctlr = 0x00000078;
+    define_arm_cp_regs(cpu, eos_digic5_cp_reginfo);
+}
+
+static void cortex_r5_initfn(Object *obj);
+
+static void arm_digic6_eos_initfn(Object *obj)
+{
+    /* Cortex R4: https://chdk.setepontos.com/index.php?topic=11316.msg124273#msg124273 */
+    cortex_r5_initfn(obj);
+    
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->midr = 0x411FC143;
+    cpu->reset_sctlr = 0x08ED0878;
+}
+
 static void arm946_initfn(Object *obj)
 {
     ARMCPU *cpu = ARM_CPU(obj);
@@ -914,9 +1009,15 @@ static void arm_v7m_class_init(ObjectClass *oc, void *data)
 
 static const ARMCPRegInfo cortexr5_cp_reginfo[] = {
     /* Dummy the TCM region regs for the moment */
-    { .name = "ATCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 0,
+    { .name = "ATCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 0,
+      .access = PL1_RW, .type = ARM_CP_CONST },
+    { .name = "BTCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 1,
+      .access = PL1_RW, .type = ARM_CP_CONST },
+    { .name = "INV_DCACHE", .cp = 15, .opc1 = 0, .crn = 15, .crm = 5, .opc2 = 0,
+      .access = PL1_RW, .type = ARM_CP_CONST },
+    { .name = "BUILDOPTS",  .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = CP_ANY,
       .access = PL1_RW, .type = ARM_CP_CONST },
-    { .name = "BTCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 1,
+    { .name = "ACTLR2",     .cp = 15, .opc1 = 0, .crn = 15, .crm = 0, .opc2 = 0,
       .access = PL1_RW, .type = ARM_CP_CONST },
     REGINFO_SENTINEL
 };
@@ -1328,6 +1429,8 @@ typedef struct ARMCPUInfo {
 static const ARMCPUInfo arm_cpus[] = {
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
     { .name = "arm926",      .initfn = arm926_initfn },
+    { .name = "arm946eos",   .initfn = arm946eos_initfn },
+    { .name = "arm-digic6-eos",   .initfn = arm_digic6_eos_initfn },
     { .name = "arm946",      .initfn = arm946_initfn },
     { .name = "arm1026",     .initfn = arm1026_initfn },
     /* What QEMU calls "arm1136-r2" is actually the 1136 r0p2, i.e. an
diff --git a/target-arm/helper.c b/target-arm/helper.c
index afc4163..46cd503 100644
--- a/target-arm/helper.c
+++ b/target-arm/helper.c
@@ -5891,11 +5891,21 @@ void arm_cpu_do_interrupt(CPUState *cs)
     /* Switch to the new mode, and to the correct instruction set.  */
     env->uncached_cpsr = (env->uncached_cpsr & ~CPSR_M) | new_mode;
     env->daif |= mask;
-    /* this is a lie, as the was no c1_sys on V4T/V5, but who cares
-     * and we should just guard the thumb mode on V4 */
-    if (arm_feature(env, ARM_FEATURE_V4T)) {
+
+    if (arm_feature(env, ARM_FEATURE_V6) ||
+        arm_feature(env, ARM_FEATURE_V7) ||
+        arm_feature(env, ARM_FEATURE_V8)) {
+        /* newer processors execute the interrupts in Thumb mode
+         * if the SCTLR TE bit is enabled */
         env->thumb = (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;
+    } else if (arm_feature(env, ARM_FEATURE_V4T)) {
+        /* there was no c1_sys on V4T/V5,
+         * and we should just guard the thumb mode on V4
+         * note: arm946eos uses the SCTLR TE bit for something else,
+         * so we can't assume this bit being always 0 on older platforms */
+        env->thumb = 0;
     }
+
     env->regs[14] = env->regs[15] + offset;
     env->regs[15] = addr;
     cs->interrupt_request |= CPU_INTERRUPT_EXITTB;
diff --git a/target-arm/helper.h b/target-arm/helper.h
index c2a85c7..2671a2c 100644
--- a/target-arm/helper.h
+++ b/target-arm/helper.h
@@ -64,6 +64,8 @@ DEF_HELPER_2(v7m_mrs, i32, env, i32)
 
 DEF_HELPER_3(access_check_cp_reg, void, env, ptr, i32)
 DEF_HELPER_3(set_cp_reg, void, env, ptr, i32)
+DEF_HELPER_3(print_set_cp_reg, void, env, ptr, i32)
+DEF_HELPER_3(print_get_cp_reg, void, env, ptr, i32)
 DEF_HELPER_2(get_cp_reg, i32, env, ptr)
 DEF_HELPER_3(set_cp_reg64, void, env, ptr, i64)
 DEF_HELPER_2(get_cp_reg64, i64, env, ptr)
diff --git a/target-arm/op_helper.c b/target-arm/op_helper.c
index 6cd54c8..46b07cf 100644
--- a/target-arm/op_helper.c
+++ b/target-arm/op_helper.c
@@ -474,6 +474,144 @@ void HELPER(set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
     ri->writefn(env, ri, value);
 }
 
+/* adapted from CHDK cpuinfo */
+static char linebuf[128];
+
+static const char *regperm_str(unsigned val) {
+    switch(val) {
+        case 0: return "P:-- U:--";
+        case 1: return "P:RW U:--";
+        case 2: return "P:RW U:R-";
+        case 3: return "P:RW U:RW";
+        case 5: return "P:R- U:--";
+        case 6: return "P:R- U:R-";
+        default:
+            return "P:?? U:??";
+    }
+}
+
+static const char *mpu_rattr(unsigned val) {
+    const char *s="";
+    const char *s2="";
+    const char *t;
+    t = (val&4)?"Shared":"Non-shared";
+    if (val&0x20) {
+        switch (val&3) {
+            case 0: s = "Inner Non-cacheable"; break;
+            case 1: s = "Inner Write-back, write-allocate"; break;
+            case 2: s = "Inner Write-through, no write-allocate"; break;
+            case 3: s = "Inner Write-back, no write-allocate"; break;
+        }
+        switch ((val&0x18)>>3) {
+            case 0: s2 = "Outer Non-cacheable"; break;
+            case 1: s2 = "Outer Write-back, write-allocate"; break;
+            case 2: s2 = "Outer Write-through, no write-allocate"; break;
+            case 3: s2 = "Outer Write-back, no write-allocate"; break;
+        }
+        sprintf(linebuf,"%s; %s; %s",s, s2, t);
+    }
+    else {
+        switch (val&0x1B) {
+            case 0: s = "Strongly ordered, shareable"; t=""; break;
+            case 1: s = "Shareable device"; t="Shareable"; break;
+            case 2: s = "Outer and Inner write-through, no write-allocate"; break;
+            case 3: s = "Outer and Inner write-back, no write-allocate"; break;
+            case 8: s = "Outer and Inner Non-cacheable"; break;
+            case 11: s = "Outer and Inner write-back, write-allocate"; break;
+            case 16: s = "Non-shareable Device"; t=""; break;
+            default: s = "(reserved)"; t="";
+        }
+        sprintf(linebuf,"%s; %s",s, t);
+    }
+    return linebuf;
+}
+
+void HELPER(print_set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+    char desc[256] = "";
+
+    if (strcmp(ri->name, "DSB") == 0)
+    {
+        return;
+    }
+    
+    /* CACHEMAINT registers come in very large groups;
+     * just display how many calls there were.
+     * fixme: if there are MRC calls, the display order may be wrong
+     */
+    static int cachemaint_count = 0;
+    static uint32_t cachemaint_pc = 0;
+    if (strcmp(ri->name, "CACHEMAINT") == 0)
+    {
+        cachemaint_pc = env->regs[15];
+        cachemaint_count++;
+        return;
+    }
+    else
+    {
+        if (cachemaint_count)
+        {
+            fprintf(stderr, "%08X: MCR p%d, ...          : CACHEMAINT x%d (omitted)\n", cachemaint_pc, ri->cp, cachemaint_count);
+            cachemaint_count = 0;
+        }
+    }
+
+    if (strncmp(ri->name, "946_PRBS", 8) == 0 &&
+        ri->cp == 15 && ri->crn == 6 && ri->opc1 == 0 && ri->opc2 == 0
+        && (value & 1))
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08lX - %08lX, 0x%lX)", base, end, size);
+    }
+
+    if (strncmp(ri->name, "XSCALE", 6) == 0 &&
+        ri->cp == 15 && ri->crn == 9 && ri->crm == 1 && ri->opc1 == 0)
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 9);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08lX - %08lX, 0x%lX)", base, end, size);
+    }
+
+    if (strcmp(ri->name, "DRSR") == 0)
+    {
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        snprintf(desc, sizeof(desc), "(0x%lX)",size);
+    }
+
+    if (strcmp(ri->name, "DRACR") == 0)
+    {
+        uint32_t rattr = value & 0x3F;
+        uint32_t accpm = (value >> 8) & 3;
+        uint32_t xn    = (value >> 12) & 1;
+        snprintf(desc, sizeof(desc),
+            "(%s; %s%s)",
+            regperm_str(accpm),
+            mpu_rattr(rattr),
+            xn ? "; Execute never" : ""
+        );
+    }
+
+    fprintf(stderr, "%08X: MCR p%d,%d,Rd,cr%d,cr%d,%d: %10s <- 0x%-8X %s\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value, desc
+    );
+}
+void HELPER(print_get_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+
+    fprintf(stderr, "%08X: MRC p%d,%d,Rd,cr%d,cr%d,%d: %10s -> 0x%X\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value
+    );
+}
+
 uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)
 {
     const ARMCPRegInfo *ri = rip;
diff --git a/target-arm/translate.c b/target-arm/translate.c
index 5d22879..d919a46 100644
--- a/target-arm/translate.c
+++ b/target-arm/translate.c
@@ -37,6 +37,8 @@
 
 #include "trace-tcg.h"
 
+#define LOG_ALL_CP_READS
+#define LOG_ALL_CP_WRITES
 
 #define ENABLE_ARCH_4T    arm_dc_feature(s, ARM_FEATURE_V4T)
 #define ENABLE_ARCH_5     arm_dc_feature(s, ARM_FEATURE_V5)
@@ -7222,6 +7224,27 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
         /* Handle special cases first */
         switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {
         case ARM_CP_NOP:
+            #if defined(LOG_ALL_CP_READS) || defined(LOG_ALL_CP_WRITES)
+            if (!is64) {
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                TCGv_i32 tmp;
+                tmpptr = tcg_const_ptr(ri);
+                if (isread) {
+                    #ifdef LOG_ALL_CP_READS
+                    tmp = load_cpu_offset(ri->fieldoffset);
+                    gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                } else {
+                    #ifdef LOG_ALL_CP_WRITES
+                    tmp = load_reg(s, rt);
+                    gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                }
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
             return 0;
         case ARM_CP_WFI:
             if (isread) {
@@ -7276,6 +7299,15 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 } else {
                     tmp = load_cpu_offset(ri->fieldoffset);
                 }
+
+                #ifdef LOG_ALL_CP_READS
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                #endif
+
                 if (rt == 15) {
                     /* Destination register of r15 for 32 bit loads sets
                      * the condition codes from the high 4 bits of the value
@@ -7287,6 +7319,19 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 }
             }
         } else {
+            #ifdef LOG_ALL_CP_WRITES
+            if (!is64) {
+                /* log all writes to coprocessor registers (32-bit) */
+                TCGv_i32 tmp;
+                TCGv_ptr tmpptr;
+                tmp = load_reg(s, rt);
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
+            
             /* Write */
             if (ri->type & ARM_CP_CONST) {
                 /* If not forbidden by access permissions, treat as WI */
