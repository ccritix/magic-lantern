/* DIGIC 6 logging experiments
 * based on dm-spy-experiments  code */

#include "dryos.h"

/* fixme */
extern __attribute__((long_call)) void DryosDebugMsg(int,int,const char *,...);
extern void dump_file(char* name, uint32_t addr, uint32_t size);
extern void * _AllocateMemory(size_t);
extern void _FreeMemory(void *);
extern int GetMemoryInformation(int *, int *);

/* custom logging buffer */
static char * buf;
static int buf_size = 0;
static int len = 0;

/* override Canon's DebugMsg to save all messages */
static void my_DebugMsg(int class, int level, char* fmt, ...)
{
    uintptr_t lr = read_lr();

    if (!buf) return;
    if (buf_size - len < 100) return;

    uint32_t old = cli();
   
    uint32_t us_timer = MEM(0xD400000C);

    char* task_name = current_task->name;
    
    /* Canon's vsnprintf doesn't know %20s */
    char task_name_padded[11] = "           ";
    int spaces = 10 - strlen(task_name);
    if (spaces < 0) spaces = 0;
    snprintf(task_name_padded + spaces, 11 - spaces, "%s", task_name);

    len += snprintf( buf+len, buf_size-len, "%05X> %s:%08x:%02x:%02x: ", us_timer, task_name_padded, lr-4, class, level );

    va_list ap;
    va_start( ap, fmt );
    len += vsnprintf( buf+len, buf_size-len-1, fmt, ap );
    va_end( ap );

    len += snprintf( buf+len, buf_size-len, "\n" );

    sei(old);
}


/* comment out one of these to see anything in QEMU */
/* on real hardware, more interrupts are expected */
static char* isr_names[0x200] = {
    [0x0A]  = "Timer",
    [0x1B]  = "Timer",
    [0x10]  = "HPTimer",
    [0x28]  = "HPTimer",
    [0x2E]  = "Term-RD",
    [0x3A]  = "Term-WR",
    [0x15D] = "Term-RD",
    [0x16D] = "Term-WR",
    [0x34]  = "SIO1",
    [0x35]  = "SIO2",
    [0x36]  = "SIO3",
    [0x147] = "SIO3",
    [0x50]  = "MREQ",
  //[0x2A]  = "MREQ",
    [0x2f]  = "DMA1",
    [0x74]  = "DMA2",
    [0x75]  = "DMA3",
    [0x76]  = "DMA4",
    [0xFE]  = "SF",
    [0xEE]  = "SD",
    [0xBE]  = "SDDMA",
    [0x13E] = "XDMAC",
    [0x14E] = "XDMAC",
    [0x15E] = "XDMAC",
    [0x16E] = "XDMAC",

    /* sorry, couldn't get dynamic code
     * to run without stack overflows...
     * (list autogenerated from qemu)
     */
    [0x58] = "EDMAC#0",
    [0x59] = "EDMAC#1",
    [0x5A] = "EDMAC#2",
    [0x5B] = "EDMAC#3",
    [0x5C] = "EDMAC#4",
    [0x6D] = "EDMAC#5",
    [0xC0] = "EDMAC#6",
    [0x5D] = "EDMAC#8",
    [0x5E] = "EDMAC#9",
    [0x5F] = "EDMAC#10",
    [0x6E] = "EDMAC#11",
    [0xC1] = "EDMAC#12",
    [0xC8] = "EDMAC#13",
    [0xF9] = "EDMAC#16",
    [0x83] = "EDMAC#17",
    [0x8A] = "EDMAC#18",
    [0xCA] = "EDMAC#19",
    [0xCB] = "EDMAC#20",
    [0xD2] = "EDMAC#21",
    [0xD3] = "EDMAC#22",
    [0x8B] = "EDMAC#24",
    [0x92] = "EDMAC#25",
    [0xE2] = "EDMAC#26",
    [0x95] = "EDMAC#27",
    [0x96] = "EDMAC#28",
    [0x97] = "EDMAC#29",
    [0xDA] = "EDMAC#32",
    [0xDB] = "EDMAC#33",
    [0x9D] = "EDMAC#40",
    [0x9E] = "EDMAC#41",
    [0x9F] = "EDMAC#42",
    [0xA5] = "EDMAC#43",
};

static void mpu_decode(char* in, char* out, int max_len);

static void pre_isr_log(uint32_t isr)
{
#ifdef CONFIG_DIGIC_VI
    extern uint32_t isr_table_handler[];
    extern uint32_t isr_table_param[];
    uint32_t handler = isr_table_handler[2 * isr];
    uint32_t arg     = isr_table_param  [2 * isr];
#endif

    /* log only unknown interrupts */
    char* name = isr_names[isr & 0x1FF];
    if (name) return;

    DryosDebugMsg(0, 15, "INT-%03Xh %X(%X)", isr, handler, arg);

    if (isr == 0x2A || isr == 0x12A || isr == 0x147)
    {
        /* SIO3/MREQ */
        extern char * mpu_send_ring_buffer[50];
        static int last_printed = 0;
        char * last_message = 0;
        while (last_message = &mpu_send_ring_buffer[last_printed][4], last_message[2])
        {
            char msg[256];
            mpu_decode(last_message, msg, sizeof(msg));
            //qprintf("[%d] mpu_send(%s)\n", last_printed, msg);
            DryosDebugMsg(0, 15, "mpu_send(%s)", msg);
            last_printed = MOD(last_printed + 1, COUNT(mpu_send_ring_buffer));
        }
    }
}

static void post_isr_log(uint32_t isr)
{
    if (isr == 0x147)
    {
        /* expecting at most one message fully received at the end of this interrupt */
        extern char * mpu_recv_ring_buffer[80];
        extern int mpu_recv_ring_buffer_tail;
        static int last_tail = 0;

        if (last_tail != mpu_recv_ring_buffer_tail)
        {
            char * last_message = &mpu_recv_ring_buffer[last_tail][4];
            char msg[256];
            mpu_decode(last_message, msg, sizeof(msg));
            //qprintf("[%d] mpu_recv(%s)\n", last_tail, msg);
            DryosDebugMsg(0, 15, "mpu_recv(%s)", msg);
            last_tail = mpu_recv_ring_buffer_tail;
        }
    }
}

extern void (*pre_isr_hook)();
extern void (*post_isr_hook)();

static void mpu_decode(char* in, char* out, int max_len)
{
    int len = 0;
    int size = in[0];

    /* print each byte as hex */
    for (char* c = in; c < in + size; c++)
    {
        len += snprintf(out+len, max_len-len, "%02x ", *c);
    }
    
    /* trim the last space */
    if (len) out[len-1] = 0;
}

#if 0
extern int (*mpu_recv_cbr)(char * buf, int size);
extern int __attribute__((long_call)) mpu_recv(char * buf);

static int mpu_recv_log(char * buf, int size_unused)
{
    int size = buf[-1];
    char msg[256];
    mpu_decode(buf, msg, sizeof(msg));
    DryosDebugMsg(0, 15, "*** mpu_recv(%02x %s)", size, msg);

    /* call the original */
    return mpu_recv(buf);
}
#endif

int GetFreeMemForAllocateMemory()
{
    int a,b;
    GetMemoryInformation(&a,&b);
    return b;
}

void log_start()
{
    /* allocate memory for our logging buffer */
    buf_size = 1024 * 1024;
    qprintf("Free memory: %X\n", GetFreeMemForAllocateMemory());
    buf = _AllocateMemory(buf_size);
    qprintf("Logging buffer: %X - %X\n", buf, buf + buf_size - 1);
    qprintf("Free memory: %X\n", GetFreeMemForAllocateMemory());
    while (!buf);

    /* override Canon's DebugMsg (requires RAM address) */
    uint32_t old_int = cli();
    uint32_t DebugMsg_addr = (uint32_t) &DryosDebugMsg & ~1;
    qprintf("Replacing %X DebugMsg with %X...\n", DebugMsg_addr, &my_DebugMsg);
    MEM(DebugMsg_addr)     = 0xC004F8DF;    /* ldr.w  r12, [pc, #4] */
    MEM(DebugMsg_addr + 4) = 0x00004760;    /* bx r12 */
    MEM(DebugMsg_addr + 8) = (uint32_t) &my_DebugMsg;
    sync_caches();
    sei(old_int);

    /* install hooks before and after each hardware interrupt */
    pre_isr_hook = &pre_isr_log;
    post_isr_hook = &post_isr_log;

#if 0
    /* wait for InitializeIntercom to complete
     * then install our own hook quickly
     * this assumes Canon's init_task is already running */
    while (!mpu_recv_cbr)
    {
        msleep(10);
    }
    mpu_recv_cbr = &mpu_recv_log;
#endif

    //dm_set_store_level(255, 1);
    DryosDebugMsg(0, 15, "Logging started.");
    DryosDebugMsg(0, 15, "Free memory: %d bytes.", GetFreeMemForAllocateMemory());

    sync_caches();
}

void log_finish()
{
    //dm_set_store_level(255, 15);
    DryosDebugMsg(0, 15, "Logging finished.");
    DryosDebugMsg(0, 15, "Free memory: %d bytes.", GetFreeMemForAllocateMemory());

    qprintf("Saving log %X size %X...\n", buf, len);
    dump_file("DEBUGMSG.LOG", (uint32_t) buf, len);

    pre_isr_hook = 0;
    post_isr_hook = 0;
    sync_caches();
}
